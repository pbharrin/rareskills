// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

import "./Dex.sol";

/**
 * From https://ethernaut.openzeppelin.com/level/22
 * "The goal of this level is for you to hack the basic DEX contract below
 * and steal the funds by price manipulation."
 */
contract TestDex {
    Dex immutable _dex;
    SwappableToken immutable _token1;
    SwappableToken immutable _token2;

    constructor() {
        // deploy dex and tokens, renounce ownership of DEX
        (_dex, _token1, _token2) = (new SetupContract()).setUp();
    }

    function swap1for2() external {
        require(_token1.balanceOf(msg.sender) > 0, "no tokens to swap");
        _dex.approve(msg.sender, 1);
        _dex.swap(address(_token1), address(_token2), 1);
    }

    function swap2for1() external {
        require(_token2.balanceOf(msg.sender) > 0, "no tokens to swap");
        _dex.approve(msg.sender, 1);
        _dex.swap(address(_token2), address(_token1), 1);
    }

    event Debug(address dexOwner, uint256 swapAmnt);

    // Assertion tests (need to have assert statements)
    function swapWorks(uint16 swapAmount16) public {
        uint256 swapAmount = uint256(swapAmount16);
        require(swapAmount > 0, "swap more than 0");
        require(swapAmount < 11, "cannot swap more than 10");
        emit Debug(msg.sender, _token1.balanceOf(msg.sender));
        _dex.approve(msg.sender, swapAmount); // 2 approvals here

        _dex.swap(address(_token1), address(_token2), swapAmount); // TODO: seems to be reverting here
        assert(swapAmount == 0);

        // assert(_token1.balanceOf(msg.sender) == 10 - swapAmount);
        assert(_token1.balanceOf(msg.sender) == 100); // this will fail for debug
    }

    /**
     * Sucess means draining all the supply from at least one of the tokens.
     */
    function echidna_dex_drained() public returns (bool) {
        uint256 THRESH = 50;

        return _dex.balanceOf(address(_token1), address(_dex)) > 99;
    }
}
