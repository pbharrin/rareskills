// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

import "./Dex.sol";

/**
 * Convenience contract to set up the Dex like Ethernaut.
 *  You start with 10 tokens of token1, and 10 of token2.
 *  The DEX starts with 100 of each.
 *
 * sender of tests (the attacker) is only addres 0x30000
 * the deployer is set to: 0x10000
 */
contract SetupContract {
    address constant ATTACKER_ADD = 0x0000000000000000000000000000000000030000;
    address constant DEPLOYER_ADD = 0x0000000000000000000000000000000000010000;

    function setUp() external returns (Dex, SwappableToken, SwappableToken) {
        Dex dex = new Dex();
        SwappableToken token1 = new SwappableToken(address(dex), "USD Coin", "USDC", 110);
        SwappableToken token2 = new SwappableToken(address(dex), "Wrapped Eth", "wETH", 110);
        dex.setTokens(address(token1), address(token2));

        // add approve and add iquidity
        token1.approve(address(dex), 100);
        token2.approve(address(dex), 100);
        dex.addLiquidity(address(token1), 100);
        dex.addLiquidity(address(token2), 100);

        // send the attacker 10 tokens
        token1.transfer(msg.sender, 10);
        token2.transfer(msg.sender, 10);

        dex.transferOwnership(DEPLOYER_ADD);

        return (dex, token1, token2);
    }
}

/**
 * From https://ethernaut.openzeppelin.com/level/22
 * "The goal of this level is for you to hack the basic DEX contract below
 * and steal the funds by price manipulation."
 */
contract TestDex {
    Dex immutable _dex;
    SwappableToken immutable _token1;
    SwappableToken immutable _token2;

    constructor() {
        // deploy dex and tokens, renounce ownership of DEX
        (_dex, _token1, _token2) = (new SetupContract()).setUp();
        assert(_token2.balanceOf(address(this)) == 10);
        assert(_token1.balanceOf(address(this)) == 10);
    }

    function swap1for2() public {
        // require(_token1.balanceOf(address(this)) > 0, "no tokens to swap");
        _dex.approve(address(_dex), 1);
        _dex.swap(address(_token1), address(_token2), 1);
    }

    function swap2for1() public {
        // require(_token2.balanceOf(address(this)) > 0, "no tokens to swap");
        _dex.approve(address(_dex), 1);
        _dex.swap(address(_token2), address(_token1), 1);
    }

    function swapMax2() public {
        // require(_token2.balanceOf(address(this)) > 1, "no tokens to swap");
        _dex.approve(address(_dex), _token2.balanceOf(address(this)));
        _dex.swap(address(_token2), address(_token1), _token2.balanceOf(address(this)));
    }

    function swapMax1() public {
        // require(_token2.balanceOf(address(this)) > 1, "no tokens to swap");
        _dex.approve(address(_dex), _token1.balanceOf(address(this)));
        _dex.swap(address(_token1), address(_token2), _token1.balanceOf(address(this)));
    }

    event Debug(address dexOwner, uint256 swapAmnt);

    // Assertion tests (need to have assert statements)
    function swapWorks(uint16 swapAmount16) private {
        uint256 swapAmount = uint256(swapAmount16);
        require(swapAmount > 0, "swap more than 0");
        require(swapAmount < 11, "cannot swap more than 10");
        emit Debug(msg.sender, _token1.balanceOf(address(this)));
        emit Debug(msg.sender, _token2.balanceOf(address(this)));
        // _token1.approve(address(_dex), swapAmount);
        _dex.approve(address(_dex), swapAmount); // 2 approvals here

        // TODO: look at try and catch, from video for debugging
        _dex.swap(address(_token1), address(_token2), swapAmount);
        emit Debug(msg.sender, _token1.balanceOf(address(this)));
        emit Debug(msg.sender, _token2.balanceOf(address(this)));
        assert(_token1.balanceOf(address(this)) == 10 - swapAmount);
        // assert(echidna_dex_drained());
    }

    /**
     * Sucess means draining all the supply from at least one of the tokens.
     */
    function echidna_dex_drained() public returns (bool) {
        uint256 THRESH = 70;
        return _dex.balanceOf(address(_token2), address(_dex)) > THRESH
            && _dex.balanceOf(address(_token1), address(_dex)) > THRESH;
    }
}
