// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

import "./Dex.sol";

/**
 * Using Echidna to test the token bonding curve.
 */
contract TestDex {
    Dex immutable _dex;
    SwappableToken immutable _token1;
    SwappableToken immutable _token2;

    constructor() {
        // deploy dex and tokens, renounce ownership of DEX
        (_dex, _token1, _token2) = (new SetupContract()).setUp();
        assert(_token2.balanceOf(address(this)) == 10);
        assert(_token1.balanceOf(address(this)) == 10);
    }

    function swap1for2() public {
        // require(_token1.balanceOf(address(this)) > 0, "no tokens to swap");
        _dex.approve(address(_dex), 1);
        _dex.swap(address(_token1), address(_token2), 1);
    }

    function swap2for1() public {
        // require(_token2.balanceOf(address(this)) > 0, "no tokens to swap");
        _dex.approve(address(_dex), 1);
        _dex.swap(address(_token2), address(_token1), 1);
    }

    function swapMax2() public {
        // require(_token2.balanceOf(address(this)) > 1, "no tokens to swap");
        _dex.approve(address(_dex), _token2.balanceOf(address(this)));
        _dex.swap(address(_token2), address(_token1), _token2.balanceOf(address(this)));
    }

    function swapMax1() public {
        // require(_token2.balanceOf(address(this)) > 1, "no tokens to swap");
        _dex.approve(address(_dex), _token1.balanceOf(address(this)));
        _dex.swap(address(_token1), address(_token2), _token1.balanceOf(address(this)));
    }

    event Debug(address dexOwner, uint256 swapAmnt);

    // Assertion tests (need to have assert statements)
    function swapWorks(uint16 swapAmount16) private {
        uint256 swapAmount = uint256(swapAmount16);
        require(swapAmount > 0, "swap more than 0");
        require(swapAmount < 11, "cannot swap more than 10");
        emit Debug(msg.sender, _token1.balanceOf(address(this)));
        emit Debug(msg.sender, _token2.balanceOf(address(this)));
        // _token1.approve(address(_dex), swapAmount);
        _dex.approve(address(_dex), swapAmount); // 2 approvals here

        // TODO: look at try and catch, from video for debugging
        _dex.swap(address(_token1), address(_token2), swapAmount);
        emit Debug(msg.sender, _token1.balanceOf(address(this)));
        emit Debug(msg.sender, _token2.balanceOf(address(this)));
        assert(_token1.balanceOf(address(this)) == 10 - swapAmount);
        // assert(echidna_dex_drained());
    }

    /**
     * Sucess means draining all the supply from at least one of the tokens.
     */
    function echidna_dex_drained() public returns (bool) {
        uint256 THRESH = 70;
        return _dex.balanceOf(address(_token2), address(_dex)) > THRESH
            && _dex.balanceOf(address(_token1), address(_dex)) > THRESH;
    }
}
